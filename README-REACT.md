# React - Теоретический доклад

## 1. React - что это?

**React** — это JavaScript-библиотека для создания пользовательских интерфейсов, разработанная компанией Meta (Facebook) в 2013 году.

### Основные характеристики:
- **Библиотека, а не фреймворк** — React решает только задачу построения UI, не навязывая решения для роутинга, управления состоянием и т.д.
- **Декларативный подход** — вы описываете, как должен выглядеть интерфейс, а React заботится о том, как это реализовать
- **Компонентная архитектура** — UI разбивается на независимые, переиспользуемые компоненты
- **Однонаправленный поток данных** — данные передаются от родительских компонентов к дочерним через props

---

## 2. Как работает React?

### Virtual DOM (Виртуальный DOM)
React использует концепцию виртуального DOM:
1. При изменении данных React создает новое виртуальное представление DOM-дерева
2. Сравнивает его с предыдущей версией (процесс называется **reconciliation**)
3. Вычисляет минимальный набор изменений
4. Применяет только эти изменения к реальному DOM

### Компоненты
Два типа компонентов:
- **Функциональные компоненты** (современный подход):
```javascript
function Welcome({ name }) {
  return <h1>Привет, {name}!</h1>;
}
```

- **Классовые компоненты** (legacy, используются реже):
```javascript
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}!</h1>;
  }
}
```

### JSX
Синтаксическое расширение JavaScript, позволяющее писать HTML-подобный код:
```javascript
const element = <h1>Hello, world!</h1>;
```

### Хуки (Hooks)
Функции, позволяющие использовать состояние и другие возможности React в функциональных компонентах:
- `useState` — управление состоянием
- `useEffect` — работа с побочными эффектами
- `useContext` — доступ к контексту
- `useRef` — ссылки на DOM-элементы
- `useMemo`, `useCallback` — оптимизация производительности
- И другие...

---

## 3. Подводные камни React

### 1. **Неправильное использование состояния**
```javascript
// ❌ Неправильно - прямая мутация
state.items.push(newItem);

// ✅ Правильно - создание нового массива
setState([...state.items, newItem]);
```

### 2. **Замыкания в useEffect и событиях**
```javascript
// ❌ Проблема - устаревшее значение count
useEffect(() => {
  setInterval(() => {
    console.log(count); // всегда 0
  }, 1000);
}, []);

// ✅ Решение - добавить зависимость
useEffect(() => {
  const interval = setInterval(() => {
    console.log(count);
  }, 1000);
  return () => clearInterval(interval);
}, [count]);
```

### 3. **Избыточные ре-рендеры**
- Создание функций и объектов внутри компонента приводит к лишним рендерам дочерних компонентов
- Решение: `useMemo`, `useCallback`, `React.memo`

### 4. **Неправильная работа с асинхронностью**
```javascript
// ❌ setState асинхронен!
setCount(count + 1);
setCount(count + 1); // count всё ещё старое значение

// ✅ Использовать функциональное обновление
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

### 5. **Key props в списках**
```javascript
// ❌ Использование индекса как key
{items.map((item, index) => <Item key={index} />)}

// ✅ Уникальный идентификатор
{items.map(item => <Item key={item.id} />)}
```

### 6. **Утечки памяти**
- Забытые подписки, таймеры, слушатели событий
- Решение: cleanup-функции в useEffect

---

## 4. Чем React хорош?

### ✅ Преимущества:

1. **Производительность**
   - Virtual DOM оптимизирует обновления
   - Рендерит только то, что действительно изменилось

2. **Переиспользуемость**
   - Компоненты можно использовать многократно
   - Легко создавать библиотеки компонентов

3. **Огромная экосистема**
   - Большое сообщество
   - Множество готовых библиотек и решений
   - React Native для мобильных приложений

4. **Декларативность**
   - Код легче читать и понимать
   - Проще предсказать результат

5. **Однонаправленный поток данных**
   - Упрощает отладку
   - Легче отслеживать изменения

6. **SEO-дружественность** (с SSR)
   - Next.js, Remix для серверного рендеринга

7. **Инструменты разработки**
   - React DevTools
   - Отличная поддержка в IDE
   - Hot Module Replacement

8. **Поддержка от Meta**
   - Регулярные обновления
   - Стабильность и надежность

---

## 5. Что нужно знать фронтенд-разработчику о React?

### Базовые концепции:

#### 1. **JSX и рендеринг**
```javascript
const element = <h1>Hello</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

#### 2. **Props (свойства)**
```javascript
function Greeting({ name, age }) {
  return <p>{name}, {age} лет</p>;
}
```

#### 3. **State (состояние)**
```javascript
const [count, setCount] = useState(0);
```

#### 4. **Жизненный цикл компонента**
- Mounting (монтирование)
- Updating (обновление)
- Unmounting (размонтирование)

#### 5. **Обработка событий**
```javascript
<button onClick={handleClick}>Нажми</button>
```

#### 6. **Условный рендеринг**
```javascript
{isLoggedIn ? <UserPanel /> : <LoginForm />}
```

#### 7. **Списки и ключи**
```javascript
{users.map(user => <User key={user.id} {...user} />)}
```

#### 8. **Формы и контролируемые компоненты**
```javascript
<input value={text} onChange={e => setText(e.target.value)} />
```

### Продвинутые темы:

#### 1. **Context API**
Для передачи данных через дерево компонентов без props drilling

#### 2. **Управление состоянием**
- Redux, MobX, Zustand, Recoil
- Когда использовать глобальное состояние

#### 3. **Оптимизация производительности**
- `React.memo` — мемоизация компонентов
- `useMemo` — мемоизация вычислений
- `useCallback` — мемоизация функций
- Code splitting и lazy loading

#### 4. **Паттерны проектирования**
- Compound Components
- Render Props
- Higher-Order Components (HOC)
- Custom Hooks

#### 5. **Тестирование**
- Jest
- React Testing Library
- E2E тесты (Cypress, Playwright)

#### 6. **TypeScript с React**
```typescript
interface Props {
  name: string;
  age: number;
}

const User: React.FC<Props> = ({ name, age }) => {
  return <div>{name}, {age}</div>;
};
```

#### 7. **Server-Side Rendering (SSR)**
- Next.js — самое популярное решение
- Улучшение SEO и производительности

#### 8. **Новые возможности React 18+**
- Concurrent Rendering
- Automatic Batching
- Transitions
- Suspense для загрузки данных
- Server Components

---

## 6. Дополнительные важные темы

### React 19 (новинки)
- **Actions** — упрощённая работа с формами и асинхронными операциями
- **use() hook** — работа с промисами и контекстом
- **Улучшенный Suspense**
- **Document Metadata** — встроенная поддержка `<title>`, `<meta>`
- **Asset Loading** — автоматическая загрузка ресурсов

### Архитектура приложения
- **Folder structure** — организация файлов и папок
- **Feature-based** vs **Type-based** структура
- Разделение логики и представления

### Best Practices (Лучшие практики)

1. **Держите компоненты маленькими** — один компонент = одна ответственность
2. **Избегайте prop drilling** — используйте Context или состояние
3. **Не оптимизируйте преждевременно** — сначала измерьте производительность
4. **Используйте TypeScript** — для больших проектов
5. **Следуйте принципам SOLID**
6. **Пишите тесты** — особенно для критичной логики
7. **Документируйте компоненты** — PropTypes или TypeScript
8. **Используйте линтеры** — ESLint, Prettier

### Экосистема и инструменты

- **Сборщики**: Vite, Webpack, Parcel
- **Фреймворки**: Next.js, Remix, Gatsby
- **Стилизация**: CSS Modules, Styled Components, Tailwind CSS, Emotion
- **UI-библиотеки**: Material-UI, Ant Design, Chakra UI
- **Роутинг**: React Router
- **Формы**: React Hook Form, Formik
- **Запросы**: React Query, SWR, Apollo Client

### Когда НЕ стоит использовать React?

- Очень простые статические сайты (лучше использовать обычный HTML/CSS)
- Проекты, где важен минимальный размер бандла
- Когда команда не знакома с React (большая кривая обучения)
- Если нет необходимости в интерактивности

---

## Заключение

React — мощный инструмент для создания современных веб-приложений. Знание его основ обязательно для фронтенд-разработчика, но важно также понимать:
- Когда его использовать
- Как правильно архитектурить приложения
- Как избегать распространённых ошибок
- Как оптимизировать производительность

**Главное правило**: начинайте с простого, усложняйте по необходимости, всегда измеряйте перед оптимизацией.

---

## Полезные ресурсы

- [Официальная документация React](https://react.dev)
- [React DevTools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
- [Patterns.dev - React Patterns](https://www.patterns.dev/)